
import { MtVec3 } from "@repcomm/mt-api";

interface vec_type {
  v: MtVec3;
  copy (this: vec_type, other: MtVec3): vec_type;
  store (this: vec_type, other: MtVec3): vec_type;
  magnitude(this: vec_type): number;
  floor (this: vec_type): vec_type;
}

const vec: vec_type = {
  v: {x: 0, y: 0, z: 0},
  //set our vector equal to another
  copy (this: vec_type, other: MtVec3) {
    this.v.x = other.x;
    this.v.y = other.y;
    this.v.z = other.z;
   return this;
  },
  //write our vector out to another vector
  store (this: vec_type, other: MtVec3) {
    other.x = this.v.x
    other.y = this.v.y
    other.z = this.v.z
    return this;
  },
   
  magnitude (this: vec_type) {
    return Math.sqrt(
      this.v.x * this.v.x +
      this.v.y * this.v.y +
      this.v.z * this.v.z
    )
  },

  floor (this: vec_type) {
    this.v.x = Math.floor(this.v.x);
    this.v.y = Math.floor(this.v.y);
    this.v.z = Math.floor(this.v.z);
    return this;
  }
}

//@ts-expect-error -- dofile() polyfill since minetest doesn't have a good way to handle require() yet
globalThis["vec"] = vec;

declare global {
  const vec: vec_type;
}
 
//  function vec:magnitude ()
//    return math.sqrt(
//      self.v.x * self.v.x +
//      self.v.y * self.v.y +
//      self.v.z * self.v.z
//    )
//  end
 
//  function vec:dot (other)
//    return (
//      self.v.x * other.x +
//      self.v.y * other.y +
//      self.v.z * other.z
//    )
//  end
 
//  function vec:zero ()
//    self.v.x = 0
//    self.v.y = 0
//    self.v.z = 0
//  end
 
//  function vec:normalize ()
//    local mag = vec:magnitude()
//    if (mag == 0) then mag = 1 end
//    vec:divScalar( mag )
//    return self
//  end
 
//  function vec:clampMagnitude(x)
//    local m = vec:magnitude()
//    if m > x then
//      vec:normalize():mulScalar(x)
//    end
//    return self
//  end
 
//  -- add to our vector by 'other' vector
//  function vec:add (other)
//   self.v.x = self.v.x + other.x
//   self.v.y = self.v.y + other.y
//   self.v.z = self.v.z + other.z
//   return self
//  end
 
//  -- subtract from our vector by 'other' vector
//  function vec:sub (other)
//   self.v.x = self.v.x - other.x
//   self.v.y = self.v.y - other.y
//   self.v.z = self.v.z - other.z
//   return self
//  end
 
//  -- multiply our vector by 'other' vector
//  function vec:mul (other)
//   self.v.x = self.v.x * other.x
//   self.v.y = self.v.y * other.y
//   self.v.z = self.v.z * other.z
//   return self
//  end
 
//  -- divide our vector by 'other' vector
//  function vec:div (other)
//   self.v.x = self.v.x / other.x
//   self.v.y = self.v.y / other.y
//   self.v.z = self.v.z / other.z
//   return self
//  end
 
//  -- add to our vector by a single number 's'
//  function vec:addScalar (s)
//   self.v.x = self.v.x + s
//   self.v.y = self.v.y + s
//   self.v.z = self.v.z + s
//   return self
//  end
 
//  -- subtract from our vector by a single number 's'
//  function vec:subScalar (s)
//   self.v.x = self.v.x - s
//   self.v.y = self.v.y - s
//   self.v.z = self.v.z - s
//   return self
//  end
 
//  -- multiple our vector by a single number 's'
//  function vec:mulScalar (s)
//   self.v.x = self.v.x * s
//   self.v.y = self.v.y * s
//   self.v.z = self.v.z * s
//   return self
//  end
 
//  -- divide our vector by a single number 's'
//  function vec:divScalar (s)
//   self.v.x = self.v.x / s
//   self.v.y = self.v.y / s
//   self.v.z = self.v.z / s
//   return self
//  end
 
//  -- compute/write quaternion rotation 'quat' as if our vector is a radian based euler rotation
//  function vec:asEulerToQuaternion (quat)
//   -- math generated by ChatGPT
//   local cosX = math.cos(self.v.x / 2)
//   local sinX = math.sin(self.v.x / 2)
//   local cosY = math.cos(self.v.y / 2)
//   local sinY = math.sin(self.v.y / 2)
//   local cosZ = math.cos(self.v.z / 2)
//   local sinZ = math.sin(self.v.z / 2)
 
//   quat.w = cosY * cosX * cosZ + sinY * sinX * sinZ
//   quat.x = cosY * sinX * cosZ + sinY * cosX * sinZ
//   quat.y = sinY * cosX * cosZ - cosY * sinX * sinZ
//   quat.z = cosY * cosX * sinZ - sinY * sinX * cosZ
 
//   return self
//  end
 
//  -- set our vector equal to the radian based euler equivalent of quaternion rotation 'quat'
//  function vec:asEulerFromQuaternion (quat)
//   -- math generated by ChatGPT
//   local sinY = 2 * (quat.w * quat.y - quat.x * quat.z)
//   local cosY = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)
//   self.v.y = math.atan2(sinY, cosY)
 
//   local sinX = 2 * (quat.w * quat.x + quat.y * quat.z)
//   local cosX = 1 - 2 * (quat.x * quat.x + quat.y * quat.y)
//   self.v.x = math.atan2(sinX, cosX)
 
//   local sinZ = 2 * (quat.w * quat.z + quat.x * quat.y)
//   local cosZ = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)
//   self.v.z = math.atan2(sinZ, cosZ)
 
//   return self
//  end
 
//  -- rotate by quaternion as if our vector is a translation
//  function vec:asTranslationApplyQuaternion (quat)
//   -- math generated by ChatGPT
//   local qx = quat.x
//   local qy = quat.y
//   local qz = quat.z
//   local qw = quat.w
 
//   local x = self.v.x
//   local y = self.v.y
//   local z = self.v.z
 
//   -- Apply the quaternion rotation
//   local ix = qw*x + qy*z - qz*y
//   local iy = qw*y + qz*x - qx*z
//   local iz = qw*z + qx*y - qy*x
//   local iw = -qx*x - qy*y - qz*z
 
//   -- Compute the output vector
//   self.v.x = -iw*qx + ix*qw - iy*qz + iz*qy
//   self.v.y = -iw*qy + ix*qz + iy*qw - iz*qx
//   self.v.z = -iw*qz - ix*qy + iy*qx + iz*qw
 
//   return self
//  end
 
//  -- convert our vector from a radian based euler rotation to a translation direction
//  function vec:asEulerToDirection ()
//   -- math generated by ChatGPT
//   local cosX = math.cos(self.v.x)
//   local sinX = math.sin(self.v.x)
//   local cosY = math.cos(self.v.y)
//   local sinY = math.sin(self.v.y)
//   local cosZ = math.cos(self.v.z)
//   local sinZ = math.sin(self.v.z)
 
//   local x = -sinY * cosX
//   local y = cosY * cosX
//   local z = sinX
 
//   self.v.x = z * sinZ * y + cosZ * x
//   self.v.y = cosZ * y - z * sinZ * x
//   self.v.z = z * cosY
 
//   return self
//  end
 
//  function vec:asDirectionToEuler()
//    vec:setXYZ(
//      math.atan2(self.v.y, self.v.x),
//      math.asin(self.v.z),
//      0
//    )
//    return self
//  end
 
//  function vec:asDirectionToMinetestEuler ()
//    vec:setXYZ(
//      math.deg(math.asin(-self.v.y)),
//      math.deg(math.atan2(self.v.x, self.v.z)),
//      90
//    )
//    return self
//  end
 
//  function vec:setXYZ (x, y, z)
//   self.v.x = x
//   self.v.y = y
//   self.v.z = z
//   return self
//  end
 
//  function vec:setX (x)
//   self.v.x = x
//   return self
//  end
 
//  function vec:setY (y)
//   self.v.y = y
//   return self
//  end
 
//  function vec:setZ (z)
//   self.v.z = z
//   return self
//  end
 
//  -- assuming our vector components x,y,z are degrees, convert to radians
//  function vec:degToRad ()
//   self.v.x = math.rad(self.v.x)
//   self.v.y = math.rad(self.v.y)
//   self.v.z = math.rad(self.v.z)
//   return self
//  end
 
//  function vec:radToDeg ()
//    self.v.x = math.deg(self.v.x)
//    self.v.y = math.deg(self.v.y)
//    self.v.z = math.deg(self.v.z)
//    return self
//  end
 
//  -- return x,y,z from internal vector
//  function vec:getXYZ ()
//   return self.v.x, self.v.y, self.v.z
//  end
 
//  function vec:getX ()
//   return self.v.x
//  end
 
//  function vec:getY ()
//   return self.v.y
//  end
 
//  function vec:getZ ()
//   return self.v.z
//  end